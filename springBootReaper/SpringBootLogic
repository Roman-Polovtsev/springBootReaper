1) Стартер  - проект, который содержит в resources/META-INF содержит файл spring.factories - там прописывается
путь, где хранится файл спринг-конфигурации, в которой декларируются все бины, что стартет должен привнести в проект.
(org.springframework.boot.autoconfigure.EnableAutoConfiguration=ru.polovtsev.StarterConfiguration) - пример
2)@SpringBootApplication внутри себя сожержит @EnableAutoConfiguration, которая в свою очередь сожержит
@Import({EnableAutoConfigurationImportSelector.class}) - этот класс сканирует classpath на предмет стартеров, посредством
класса SpringFactoriesLoader ищет в них spring.factories, который проверяет на налчие
org.springframework.boot.autoconfigure.EnableAutoConfiguration=...
Центральная зависимость бута - spring-boot-autoconfigure.jar в своем spring.factories на месте
org.springframework.boot.autoconfigure.EnableAutoConfiguration= ... имеет огромный список всевозможных записей вроде
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration или org.springframework.boot.autoconfigure.amqp.RabbitAutoCOnfiguration
всего 90 с чем то, плюс многие из этих конфигураций под капотом имеют тоже importSelector, который подтягивает еще кучу более
подробных захардкоженных конфигураций всех возможных вариантов реализации базовой конфигурации (например, для автоконфигурации кэша
подтгиваются конфигурации его реализаций: EhCacheAutoconfiguration.class, RedisCacheAutoconfiguration.class и тд).
Это для уменьшения количества стартеров (их логически объединили, чтоб не писать миллион на все варианты). То есть конфигурации
приходят, как со стороны (подключенных внешних стартеров), так и из центральной зависимости бута
org.springframework.boot.autoconfigure, где прописаны основные, по мнению разработчиков, конфигурации.
3) Далее эти конфигурации фильтруются при помощи @ConditionalOn.. аннотаций.
Можно написать свою аннтоацию @ConditionalOn... и пометить ей конфигурацию или конкретный бин, для этого нужно внутри
аннотации необходимо указать аннотацию @Conditional(YourConditionalLogic.class), где YourConditionalLogic - класс,
реализующий интерфейс Condition и переопределяюший единственный его метод 'matches',
вовращаеющий boolean (выполнилось условие или нет)
4)Если хочется иметь возможность заоверрайдить какой то из бинов, привносимых стартером, например написать свой бин datasource
для spring data, то стартер должен помечать этот бин аннотацией @ConditionalOnMissingBean, куда можно передать либо класс
бина, либо его имя, которое по дефолту = имени метода, создающего бин под @Bean. При этом важно понимать, что если условно
ставим эту аннотацию например на бин для класса ApplicationListener, коих может создавать кучу разных под разными именами
каждый стартер, то если эти стартеры отработают раньше, чем наш, то естественно бин такого класса существовать будет и
наша аннотация не принесет успеха - поэтому лучше давать конкретные айдишники бинам типа "MyListner", и добавлять в аннотацию
условие проверки именно по этому id.
5)Если необхожимо внедриться на достаточно раннем этапе запуска приложения - до создания бинов, бин дефинишнов, но когда
уже создан контекст, то можно использовать ApplicationContextInitializer, который содержит в себе только Environment -
набор всевозможных параметров, переменных окружения и тд. Все это нужно, например, если нам нужно скажем не давать подниматься
приложению, если не задан какой то из параметров - например не указан активный профиль. Чтобы это сделать, необходимо
заимплементить ApplicationContextInitializer и реализовать единсвтенный его метод, принимающий ApplicationContext, так
как это требуется. Поскольку как бин такой класс не зарегистрировать - так как он должен отрабатывать до создания бинов,
то прописываем его в spring.factories:
org.springframework.context.ApplicationContextInitializer=ru.polovtsev.MyContextInitializer
6) Если необходимо вклиниться еще раньше - на этапе построения Environment - например, чтобы задать свой дефолтный
профиль по некоторому условию, который будет принят, если не будет переодпределн позднее, то необходимо использовать
EnvironmentPostProcessor. Он отрабатывает на этапе, когда еще даже контекст не построен. Аналогично
ApplicationContextInitilizer'у, необходимо заимплементить интерфейс EnvironmentPostProcessor, переопределить его метод,
а после прописать в spring.factories:
org.springframework.boot.env.EnvironmentPostProcessor=ru.polovtsev.MyEnvironmentPostProcessor
